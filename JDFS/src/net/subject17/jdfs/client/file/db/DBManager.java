package net.subject17.jdfs.client.file.db;

import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import net.subject17.jdfs.JDFSUtil;
import net.subject17.jdfs.client.file.FileUtil;
import net.subject17.jdfs.client.io.Printer;
import net.subject17.jdfs.security.JDFSSecurity;

public class DBManager {
	public static final class DBManagerFatalException extends Exception {
		private static final long serialVersionUID = -749681840594206045L;
		public DBManagerFatalException()							{super();}
		public DBManagerFatalException(String msg)					{super(msg);}
		public DBManagerFatalException(String msg, Throwable thrw)	{super(msg,thrw);}
		public DBManagerFatalException(Exception e)	{super(e);}
	}
	
	public static final int maxRecordsToGrab = 1000;
	
	private final static String dbUser = "SA";
	private final static String dbPassword = "";
	
	private static DBManager _instance = null;
	
	protected DBManager() throws DBManagerFatalException {
		try {
			initializeDatabase();
			
		} catch(SQLException e){
			Printer.logErr("An error occured initializing the database");
			Printer.logErr(e);
			throw new DBManagerFatalException(e);
		}
	}
	
	public static DBManager getInstance() throws DBManagerFatalException {
		if (null == _instance){
			synchronized(DBManager.class){
				if (null == _instance){
					_instance = new DBManager(); //Initialization can throw exception, so can't do normal singleton instantiation method
				}
			}
		}
		return _instance;
	};
	
	private String getDBLocation(){
		return Paths.get(JDFSUtil.defaultDirectory,"DB","jdfs.hsqldb").toString();
	}

	private Connection getConnection() throws SQLException {
		/* Apparently this is unneeded for Java 7
		  try {
		      Class.forName("org.hsqldb.jdbc.JDBCDriver" );
		  } catch (Exception e) {
		      System.err.println("ERROR: failed to load HSQLDB JDBC driver.");
		      e.printStackTrace();
		  }
		  */
		  return DriverManager.getConnection("jdbc:hsqldb:file:"+getDBLocation()+";shutdown=true", dbUser, dbPassword);
	}
	
	private void initializeDatabase() throws SQLException {
		/*				Design notes:
		 * We could load in these statements from a file, but considering their short length, I feel that's more
		 * effort t`han it would be worth.  Also, I don't want to risk that file being deleted.
		 * 
		 * Also, in a future release, these could be combined into a single execution, but I find seperating them
		 * is easier to debug.
		 * 
		 * Users Table:  UserID is not the PK since it's randomly generated for each user.
		 * 	While I'm hoping account emails will be naturally unique, I feel it's possible
		 * 	to find users with the same username+account combo in the wild
		 * 	Remember, people are lazy, and there could be a lot of {UserName:'john doe', UserEmail:'fake@mailinator.net'}
		 * 	out there
		 * 
		 * Peers Table:  Note the duplication of data from users table.  Really, the only difference between a "peer"
		 * 	and a "user" in the context of this program is whether or not that object has an account on the machine
		 * 	running this program.  If so, then they're a user.  If not, they're a peer.  Otherwise, they have the same
		 * 	data
		 * 	
		 * Files Tables: We always receive a file if it doesn't have the same checksum as the one currently stored.
		 * 	However, for 
		 * 
		 * Ip6's and Ip4's
		 */
		
		
		try(Connection conn = getConnection();
			Statement statement = conn.createStatement()
		){
			//Create users table if it doesn't exist
			Printer.log("Ensuring Users Table Exists");
			statement.execute("CREATE TABLE IF NOT EXISTS Users ("+
							"UserPK INTEGER Generated By DEFAULT As IDENTITY PRIMARY KEY, "+
							"UserGUID VARCHAR(36) NOT NULL UNIQUE, "+
							"UserName VARCHAR(36) NOT NULL, "+
							"AccountEmail VARCHAR(36) NOT NULL"+
			")");
			
			//Create peers table if it doesn't exist
			Printer.log("Ensuring Peers Table Exists");
			statement.execute("CREATE TABLE IF NOT EXISTS Peers ("+
							"PeerPK INTEGER Generated By DEFAULT As IDENTITY PRIMARY KEY, "+
							"PeerGUID VARCHAR(36) NOT NULL,"+
							"UserName VARCHAR(36) NOT NULL,"+
							"AccountEmail VARCHAR(36) NOT NULL"+
							//"MachineGUID VARCHAR(36) NOT NULL"+
			")");
			
			//Create user files table if it doesn't exist
			Printer.log("Ensuring UserFiles Table Exists");
			statement.execute("CREATE TABLE IF NOT EXISTS UserFiles ("+
							"UserFilePK INTEGER Generated By DEFAULT As IDENTITY PRIMARY KEY, "+
							"FileGUID VARCHAR(36) NOT NULL, " +
							"LocalFileName VARCHAR(2000) NOT NULL, " +
							"LocalFilePath VARCHAR(2000) NOT NULL, " + //including name
							"LastUpdatedLocal DATETIME, " +
							"CheckSum VARCHAR(36), " + 
							"IV VARCHAR("+JDFSSecurity.NUM_IV_BYTES*2+") DEFAULT '', " + //For storing incoming files we didn't have a chance to decrypt yet
							"ParentGUID VARCHAR(36), " +
							"RelativeParentPath VARCHAR(2000), " +
							"Priority INTEGER DEFAULT 0 NOT NULL" + //Default priority = 0, lower priorities < 0 and higher priorities >0
			")");

			//Create peer files table if it doesn't exist
			Printer.log("Ensuring PeerFiles Table Exists");
			statement.execute("CREATE TABLE IF NOT EXISTS PeerFiles ("+
							"FilePK INTEGER Generated By DEFAULT As IDENTITY PRIMARY KEY, "+
							"FileGUID VARCHAR(36) DEFAULT '' NOT NULL, " +
							"LocalFileName VARCHAR(2000) NOT NULL, " + //NOTE THE DATATYPE!  MAJOR PREFORMANCE ISSUE POSSIBLE!
							"LocalFilePath VARCHAR(2000) NOT NULL, " + //including name
							"PathOnClient VARCHAR(2000) DEFAULT '' NOT NULL, " + //including name
							"UpdatedDate DATETIME NOT NULL, " +
							"IV VARCHAR("+JDFSSecurity.NUM_IV_BYTES*2+") NOT NULL, " +
							"ParentGUID VARCHAR(36) DEFAULT '', " +
							"RelativeParentPath VARCHAR(2000) DEFAULT '', " +
							"Priority INT DEFAULT 0 NOT NULL, " + //Default priority = 0, lower priorities < 0 and higher priorities >0
							"CheckSum VARCHAR("+FileUtil.NUM_CHECKSUM_BYTES*2+") NOT NULL" +
			")");
			
			//Create machines table if it doesn't exist
			Printer.log("Ensuring Machines Table Exists");
			statement.execute("CREATE TABLE IF NOT EXISTS Machines ("+
							"MachinePK INTEGER Generated By DEFAULT As IDENTITY PRIMARY KEY, "+
							"MachineGUID VARCHAR(36) NOT NULL UNIQUE"+
			")");
			
			///////////////////////////
			// Create Linking Tables //
			///////////////////////////

			Printer.log("Ensuring Linking Tables Exist");
			//Create User Files Link table if it doesn't exist
			statement.execute("CREATE TABLE IF NOT EXISTS UserFileLinks ("+
							"LinkID INTEGER Generated By DEFAULT As IDENTITY PRIMARY KEY, "+
							"UserFilePK INTEGER NOT NULL, "+
							"UserPK INTEGER NOT NULL, "+
							"MachinePK INTEGER NOT NULL"+
			")");
			
			//Create Peer Files Link table if it doesn't exist
			statement.execute("CREATE TABLE IF NOT EXISTS PeerFileLinks ("+
							"LinkID INTEGER Generated By DEFAULT As IDENTITY PRIMARY KEY, "+
							"PeerFilePK INTEGER NOT NULL,"+
							"PeerPK INTEGER NOT NULL,"+
							"MachinePK INTEGER NOT NULL"+
			")");
			
			//Create Machine Users Link table if it doesn't exist
			statement.execute("CREATE TABLE IF NOT EXISTS MachineUserLinks ("+
							"LinkID INTEGER Generated By DEFAULT As IDENTITY PRIMARY KEY, "+
							"MachinePK INTEGER NOT NULL, "+
							"UserPK INTEGER NOT NULL"+
			")");
			
			//Create Machine Peers Link table if it doesn't exist
			statement.execute("CREATE TABLE IF NOT EXISTS MachinePeerLinks ("+
							"LinkID INTEGER Generated By DEFAULT As IDENTITY PRIMARY KEY, "+
							"MachinePK INTEGER NOT NULL, "+
							"PeerPK INTEGER NOT NULL"+
			")");
			
			//Create Machine IP4 Link table if it doesn't exist
			statement.execute("CREATE TABLE IF NOT EXISTS MachineIP4Links ("+
							"LinkID INTEGER Generated By DEFAULT As IDENTITY PRIMARY KEY, "+
							"MachinePK INTEGER NOT NULL, "+
							"IP4 VARCHAR(16) NOT NULL"+
			")");
			
			//Create Machine IP6 Link table if it doesn't exist
			statement.execute("CREATE TABLE IF NOT EXISTS MachineIP6Links ("+
							"LinkID INTEGER Generated By DEFAULT As IDENTITY PRIMARY KEY, "+
							"MachinePK INTEGER NOT NULL, "+
							"IP6 VARCHAR(46) NOT NULL"+
			")");
			
			//auto closes statement and connection
		}
	}
	
	//For testing
	public boolean truncateEverything2() throws SQLException {
		try(Connection conn = getConnection();
			Statement statement = conn.createStatement()
		){
			statement.execute("TRUNCATE TABLE Users AND COMMIT NO CHECK");
			statement.execute("TRUNCATE TABLE Peers AND COMMIT NO CHECK");
			statement.execute("TRUNCATE TABLE UserFiles AND COMMIT NO CHECK");
			statement.execute("TRUNCATE TABLE PeerFiles AND COMMIT NO CHECK");
			statement.execute("TRUNCATE TABLE Machines AND COMMIT NO CHECK");
			statement.execute("TRUNCATE TABLE UserFileLinks AND COMMIT NO CHECK");
			statement.execute("TRUNCATE TABLE PeerFileLinks AND COMMIT NO CHECK");
			statement.execute("TRUNCATE TABLE MachineUserLinks AND COMMIT NO CHECK");
			statement.execute("TRUNCATE TABLE MachinePeerLinks AND COMMIT NO CHECK");
			statement.execute("TRUNCATE TABLE MachineIP4Links AND COMMIT NO CHECK");
			statement.execute("TRUNCATE TABLE MachineIP6Links AND COMMIT NO CHECK");
		}
		return true;
	}
	
	//For testing
	public boolean dropEverything2() throws SQLException {
		try(Connection conn = getConnection();
			Statement statement = conn.createStatement()
		){
			statement.execute("DROP TABLE IF EXISTS Users");
			statement.execute("DROP TABLE IF EXISTS Peers");
			statement.execute("DROP TABLE IF EXISTS UserFiles");
			statement.execute("DROP TABLE IF EXISTS PeerFiles");
			statement.execute("DROP TABLE IF EXISTS Machines");
			statement.execute("DROP TABLE IF EXISTS UserFileLinks");
			statement.execute("DROP TABLE IF EXISTS PeerFileLinks");
			statement.execute("DROP TABLE IF EXISTS MachineUserLinks");
			statement.execute("DROP TABLE IF EXISTS MachinePeerLinks");
			statement.execute("DROP TABLE IF EXISTS MachineIP4Links");
			statement.execute("DROP TABLE IF EXISTS MachineIP6Links");
		}
		return true;
	}
	
	public void finalizeSession() throws DBManagerFatalException { //Possibly add flag, or make connection class property?
		try(Connection conn = getConnection();
			Statement statement = conn.createStatement()
		){
			Printer.log("Finalizing DB session");
			statement.execute("SHUTDOWN");
		}
		catch (SQLException e) {
			Printer.logErr("An error occured while finalizing the database");
			Printer.logErr(e);
			throw new DBManagerFatalException(e);
		}
	}
	
	//Got rid of try/catch due to issues with premature closing of getGeneratedKeys result set
	public ResultSet upsert(String sql) throws SQLException {
		Printer.log(sql, Printer.Level.VeryLow);
		
		
		//try(
			Connection conn = getConnection();
			Statement statement = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,  ResultSet.CONCUR_UPDATABLE, ResultSet.HOLD_CURSORS_OVER_COMMIT);
		//){
			statement.closeOnCompletion();
			statement.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
			return statement.getGeneratedKeys();
		//}
	}
	/* This code works
	public int upsert2(String sql) throws SQLException {
		try( Connection conn = DriverManager.getConnection("jdbc:hsqldb:file:"+getDBLocation(), dbUser, dbPassword);
			 Statement statement = conn.createStatement()
		){
			Printer.log(sql);
			statement.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
			ResultSet resset = statement.getGeneratedKeys();
			Printer.log("Col tr"+resset.isBeforeFirst());
			if (resset.next()) {Printer.log("hunky dorey");} else {Printer.log("fucker");}
			Printer.log("Cursor name:"+resset.getCursorName());
			Printer.log("Col count"+resset.getMetaData().getColumnCount());
			Printer.log("Col count"+resset.getMetaData().getColumnName(1));
			return resset.getInt("MachinePK");
		}
	}*/
	public ResultSet select(String sql) throws SQLException {
		Printer.log(sql, Printer.Level.VeryLow);
		
		try( Connection conn = getConnection();
			 //Statement statement = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
				Statement statement = conn.createStatement();
		){
			return statement.executeQuery(sql);
		}
	}
	
	public ResultSet delete(String sql) throws SQLException {
		Printer.log(sql, Printer.Level.VeryLow);
		
		try( Connection conn = getConnection();
			 Statement statement = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE)
		){
			return statement.executeQuery(sql);
		}
	}
	
	public void writeTableToLog(String tableName) {
		try (ResultSet resSet = select("SELECT * FROM "+tableName)) {
			
			final int numCols = resSet.getMetaData().getColumnCount();
			
			while(resSet.next()) {
				Printer.log("Next Result:");
				String row = "";
				for (int i = 1; i <= numCols; ++i) {
					row += "Col #"+i+": "+resSet.getString(i)+"; ";
				}
				Printer.log(row);
			}
			Printer.log("Done with table "+tableName);
			
		} catch (SQLException e) {
			Printer.logErr(e);
		}
	}
}
